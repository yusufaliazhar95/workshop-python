# minggu-09

## Kelas

Kelas menyediakan sarana untuk menggabungkan data dan fungsi bersama. Membuat kelas baru menciptakan jenis objek baru, yang memungkinkan instance baru dari jenis itu dibuat. Setiap instance kelas dapat memiliki atribut yang melekat padanya untuk mempertahankan statusnya. Instance kelas juga dapat memiliki metode (ditentukan oleh kelasnya) untuk memodifikasi statusnya.

Dibandingkan dengan bahasa pemrograman lainnya, mekanisme kelas Python menambahkan kelas dengan minimal sintaks dan semantik baru. Ini adalah campuran dari mekanisme kelas yang ditemukan di C ++ dan Modula-3. Kelas Python menyediakan semua fitur standar Pemrograman Berorientasi Objek: mekanisme pewarisan kelas memungkinkan beberapa kelas dasar, kelas turunan dapat mengesampingkan metode apa pun dari kelas dasar atau kelasnya, dan metode dapat memanggil metode kelas dasar dengan nama yang sama . Objek dapat berisi jumlah dan jenis data yang sewenang-wenang. Seperti benar untuk modul, kelas mengambil bagian dari sifat dinamis Python: mereka dibuat saat runtime, dan dapat dimodifikasi lebih lanjut setelah pembuatan.

Dalam terminologi C ++, biasanya anggota kelas (termasuk anggota data) bersifat publik (kecuali lihat di bawah Variabel Pribadi), dan semua fungsi anggota adalah virtual. Seperti dalam Modula-3, tidak ada singkatan untuk mereferensikan anggota objek dari metodenya: fungsi metode dideklarasikan dengan argumen pertama eksplisit yang mewakili objek, yang diberikan secara implisit oleh panggilan. Seperti dalam Smalltalk, kelas itu sendiri adalah objek. Ini menyediakan semantik untuk mengimpor dan mengganti nama. Tidak seperti C ++ dan Modula-3, tipe built-in dapat digunakan sebagai kelas dasar untuk ekstensi oleh pengguna. Juga, seperti di C ++, sebagian besar operator built-in dengan sintaks khusus (operator aritmatika, subscripting, dll.) Dapat didefinisikan ulang untuk instance kelas.

(Kurang terminologi yang diterima secara universal untuk berbicara tentang kelas, saya akan menggunakan istilah Smalltalk dan C ++ sesekali. Saya akan menggunakan istilah Modula-3, karena semantik berorientasi objeknya lebih dekat dengan Python daripada C ++, tapi saya berharap bahwa beberapa pembaca telah mendengarnya.)

## Sebuah Kata Tentang Nama dan Objek

Objek memiliki individualitas, dan beberapa nama (dalam berbagai cakupan) dapat terikat ke objek yang sama. Ini dikenal sebagai aliasing dalam bahasa lain. Ini biasanya tidak dihargai pada pandangan pertama Python, dan dapat dengan aman diabaikan ketika berhadapan dengan jenis dasar yang tidak dapat diubah (angka, string, tupel). Namun, aliasing memiliki efek yang mungkin mengejutkan pada semantik kode Python yang melibatkan objek yang dapat berubah seperti daftar, kamus, dan sebagian besar jenis lainnya. Ini biasanya digunakan untuk kepentingan program, karena alias bertindak seperti pointer dalam beberapa hal. Sebagai contoh, melewati suatu objek adalah murah karena hanya pointer yang dilewatkan oleh implementasi; dan jika fungsi memodifikasi objek yang dilewatkan sebagai argumen, pemanggil akan melihat perubahan - ini menghilangkan kebutuhan untuk dua mekanisme pengalihan argumen yang berbeda seperti dalam Pascal.

Lingkup Python dan Namespaces
Sebelum memperkenalkan kelas, pertama-tama saya harus memberi tahu Anda sesuatu tentang aturan lingkup Python. Definisi kelas memainkan beberapa trik rapi dengan ruang nama, dan Anda perlu mengetahui ruang lingkup dan ruang nama berfungsi untuk memahami apa yang sebenarnya terjadi. Kebetulan, pengetahuan tentang subjek ini berguna untuk programmer Python maju.

Mari mulai dengan beberapa definisi.

Namespace adalah pemetaan dari nama ke objek. Kebanyakan ruang nama saat ini diterapkan sebagai kamus Python, tetapi itu biasanya tidak terlihat dengan cara apa pun (kecuali untuk kinerja), dan mungkin akan berubah di masa mendatang. Contoh ruang nama adalah: kumpulan nama bawaan (berisi fungsi seperti abs (), dan nama pengecualian bawaan); nama-nama global dalam sebuah modul; dan nama-nama lokal dalam doa fungsi. Dalam arti set atribut suatu objek juga membentuk namespace. Yang penting untuk diketahui tentang ruang nama adalah bahwa sama sekali tidak ada hubungan antara nama di ruang nama yang berbeda; misalnya, dua modul yang berbeda dapat mendefinisikan fungsi yang dimaksimalkan tanpa kebingungan - pengguna modul harus menambahkannya dengan nama modul.

By the way, saya menggunakan atribut kata untuk setiap nama mengikuti titik - misalnya, dalam ekspresi z.real, nyata adalah atribut dari objek z. Secara tegas, referensi untuk nama dalam modul adalah referensi atribut: dalam ekspresi modname.funcname, modname adalah objek modul dan funcname adalah atributnya. Dalam hal ini terjadi pemetaan langsung antara atribut modul dan nama global yang didefinisikan dalam modul: mereka berbagi namespace yang sama! [1]

Atribut dapat bersifat hanya-baca atau dapat ditulis. Dalam kasus terakhir, penugasan ke atribut dimungkinkan. Atribut modul dapat ditulis: Anda dapat menulis modname.the_answer = 42. Atribut yang dapat dihapus juga dapat dihapus dengan pernyataan del. Sebagai contoh, del modname.the_answer akan menghapus atribut the_answer dari objek yang dinamai oleh modname.

Namespaces dibuat pada momen yang berbeda dan memiliki masa kehidupan yang berbeda. Namespace yang berisi nama built-in dibuat ketika interpreter Python dijalankan, dan tidak pernah dihapus. Namespace global untuk modul dibuat ketika definisi modul dibaca; biasanya, ruang nama modul juga bertahan sampai juru bahasa berhenti. Pernyataan yang dieksekusi oleh permintaan tingkat tinggi dari penerjemah, baik dibaca dari file skrip atau secara interaktif, dianggap sebagai bagian dari modul yang disebut __main__, sehingga mereka memiliki namespace global sendiri. (Nama bawaan sebenarnya juga ada dalam modul; ini disebut builtins.)
